# -*- cython -*-
# cython: boundscheck=False, wraparound=False, cdivision=True, initializedcheck=False
# distutils: language = c++
#
#
# Tempita-templated Cython file
#
"""
Fast snippets for LIL matrices.
"""

ctypedef long double ldouble
ctypedef float complex fcomplex
ctypedef double complex dcomplex
ctypedef long double complex ldcomplex

{{py:

IDX_TYPES = {
    "int32": "cnp.npy_int32",
    "int64": "cnp.npy_int64",
}

VALUE_TYPES = {
    "bool": "cnp.npy_bool",
    "int8": "cnp.npy_int8",
    "uint8": "cnp.npy_uint8",
    "int16": "cnp.npy_int16",
    "uint16": "cnp.npy_uint16",
    "int32": "cnp.npy_int32",
    "uint32": "cnp.npy_uint32",
    "int64": "cnp.npy_int64",
    "uint64": "cnp.npy_uint64",
    "float32": "cnp.npy_float32",
    "float64": "cnp.npy_float64",
    "float128": "cnp.npy_float128",
    "complex64": "fcomplex",
    "complex128": "dcomplex",
    "complex256": "ldcomplex",
}


def get_dispatch(types):
    for pyname, cyname in types.items():
        yield pyname, cyname

def get_dispatch2(types, types2):
    for pyname, cyname in types.items():
        for pyname2, cyname2 in types2.items():
            yield pyname, pyname2, cyname, cyname2
}}


cimport cython
cimport numpy as cnp
cnp.import_array()
import numpy as np

from cpython cimport *
from cython.operator cimport dereference as deref
from libcpp.vector cimport vector

cdef extern from "./sparsetools/vov.h" namespace "vov":
    cdef int check_index[I](PyObject*,
                            I*)
    cdef int check_slice_index(PyObject*, Py_ssize_t,
                               Py_ssize_t*,
                               Py_ssize_t*,
                               Py_ssize_t*)
    cdef int check_two_tuple(object, PyObject**, PyObject**)
    cdef int breakpoint()
    cdef cppclass VOVMatrix[I, T]:
        VOVMatrix(I, I) except +
        void set(I, I, T) except +
        void set_unchecked(I, I, T)
        T get(I, I) except +
        T get_unchecked(I, I)
        void fromcsr(cnp.PyArrayObject*,
                     cnp.PyArrayObject*,
                     cnp.PyArrayObject*)
        void todense(cnp.PyArrayObject*)
        void tocsr(cnp.PyArrayObject*,
                     cnp.PyArrayObject*,
                     cnp.PyArrayObject*)
        void mul(T)
        VOVMatrix[I, T] *copy()
        I getnnz_all()
        void getnnz_per_row(I*)
        void getnnz_per_col(I*)
        I count_nonzero()
        VOVMatrix[I, T] *fancy_get_elems(cnp.PyArrayObject*,
                                         cnp.PyArrayObject*, I) except +
        VOVMatrix[I, T] *fancy_get_rows(cnp.PyArrayObject*, I) except +
        VOVMatrix[I, T] *fancy_get_cols(cnp.PyArrayObject*, I) except +
        VOVMatrix[I, T] *fancy_get(cnp.PyArrayObject*,
                                   cnp.PyArrayObject*,
                                   I, I) except +
        void fancy_set(I*, I*, T*, I) except +
        VOVMatrix[I, T] *reshape(I, I) except +


{{for PYIDX, PYVALUE, IDX_T, VALUE_T in get_dispatch2(IDX_TYPES, VALUE_TYPES)}}
cdef class fast_lil_matrix_{{PYIDX}}_{{PYVALUE}}:
    """
    Fast row-based matrix.
    """

    cdef {{IDX_T}} rows
    cdef {{IDX_T}} cols

    cdef VOVMatrix[{{IDX_T}}, {{VALUE_T}}] *vov

    def __init__(self, {{IDX_T}} rows, {{IDX_T}} cols):

        self.rows = rows
        self.cols = cols

        self.vov = new VOVMatrix[{{IDX_T}}, {{VALUE_T}}](rows, cols)

    def idx_dtype(self):
        """
        Return the index dtype.
        """

        return np.dtype('{{PYIDX}}')

    cdef void set(self, {{IDX_T}} row, {{IDX_T}} col, {{VALUE_T}} value):
        """
        Set (row, col) to value, without bounds checking.
        """

        self.vov.set_unchecked(row, col, value)

    def safe_set(self, {{IDX_T}} row, {{IDX_T}} col, {{VALUE_T}} value):
        """
        Set (row, col) to value, with bounds checking.
        """

        self.vov.set(row, col, value)

    def safe_get(self, {{IDX_T}} row, {{IDX_T}} col):
        """
        Get value at (row, col), with bounds checking.
        """

        return self.vov.get(row, col)

    cdef {{VALUE_T}} get(self, {{IDX_T}} row, {{IDX_T}} col):
        """
        Get value at (row, col), without bounds checking.
        """

        return self.vov.get_unchecked(row, col)

    def __getitem__(self, index):

        cdef {{IDX_T}} row_idx, col_idx
        cdef PyObject *i, *j
        cdef int i_slice, j_slice
        cdef Py_ssize_t j_start, j_stop, j_step
        cdef Py_ssize_t i_start, i_stop, i_step

        if check_two_tuple(index, &i, &j):

            if check_index(i, &row_idx) and check_index(j, &col_idx):
                return self.vov.get(row_idx, col_idx)
            
            i_slice = check_slice_index(i,
                                        self.rows,
                                        &i_start,
                                        &i_stop,
                                        &i_step)
            j_slice = check_slice_index(j,
                                        self.cols,
                                        &j_start,
                                        &j_stop,
                                        &j_step)

            if (i_slice and j_slice
                and i_start == 0 and i_stop == self.rows and i_step == 1
                and j_start ==0 and j_stop == self.cols and j_step == 1):
                return self.copy()


    cpdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} fancy_get_elems(self,
                                                                row_indices,
                                                                col_indices):
        """
        Fancy indexing: get elements at coordinates given by
        row and column indices.
        """

        cdef {{IDX_T}} rows, cols
        cdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} mat

        rows = 1
        cols = row_indices.shape[0]

        mat = fast_lil_matrix_{{PYIDX}}_{{PYVALUE}}(rows, cols)
        del mat.vov
        mat.vov = self.vov.fancy_get_elems(<cnp.PyArrayObject*>row_indices,
                                           <cnp.PyArrayObject*>col_indices,
                                           row_indices.shape[0])
        return mat

    cpdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} fancy_get_rows(self,
                                                               row_indices):
        """
        Fancy indexing: get rows indicated by row_indices.
        """

        cdef {{IDX_T}} i, rows, row_idx

        rows = row_indices.shape[0]

        mat = fast_lil_matrix_{{PYIDX}}_{{PYVALUE}}(rows, self.cols)
        del mat.vov
        mat.vov = self.vov.fancy_get_rows(<cnp.PyArrayObject*>row_indices,
                                          row_indices.shape[0])

        return mat

    cpdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} fancy_get_cols(self,
                                                               col_indices):
        """
        Fancy indexing: get cols indicated by col_indices.
        """

        cdef {{IDX_T}} cols

        cols = col_indices.shape[0]

        mat = fast_lil_matrix_{{PYIDX}}_{{PYVALUE}}(self.rows, cols)
        del mat.vov
        mat.vov = self.vov.fancy_get_cols(<cnp.PyArrayObject*>col_indices,
                                          col_indices.shape[0])

        return mat

    cpdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} fancy_get(self,
                                                          {{IDX_T}} rows,
                                                          {{IDX_T}} cols,
                                                          i_idx,
                                                          j_idx):
        """
        Fancy indexing: the rest.
        """

        cdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} mat

        mat = fast_lil_matrix_{{PYIDX}}_{{PYVALUE}}(rows, cols)
        del mat.vov
        mat.vov = self.vov.fancy_get(<cnp.PyArrayObject*> i_idx,
                                     <cnp.PyArrayObject*> j_idx,
                                     rows, cols)

        return mat

    cpdef fancy_set(self,
                    {{IDX_T}}[:, :] i_idx,
                    {{IDX_T}}[:, :] j_idx,
                    data):

        cdef unsigned long data_ptr = data.ctypes.data

        self.vov.fancy_set(&i_idx[0, 0],
                           &j_idx[0, 0],
                           <{{VALUE_T}}*>(<void*> data_ptr),
                           i_idx.size)

    cpdef todense(self, dense):

        self.vov.todense(<cnp.PyArrayObject*> dense)

    cpdef mul(self, {{VALUE_T}} value):

        self.vov.mul(value);

    cpdef {{IDX_T}} count_nonzero(self):

        return self.vov.count_nonzero()

    cpdef getnnz(self, axis):

        cdef {{IDX_T}} i, j, col
        cdef {{IDX_T}} nnz = 0

        cdef vector[{{IDX_T}}] *row_indices
        cdef cnp.ndarray[{{IDX_T}}, ndim=1] nnz_array

        if axis is None:
            return self.vov.getnnz_all()

        if axis == 1:
            nnz_array = np.empty(self.rows, dtype=np.{{PYIDX}})
            self.vov.getnnz_per_row(&nnz_array[0])

        if axis == 0:
            nnz_array = np.zeros(self.cols, dtype=np.{{PYIDX}})
            self.vov.getnnz_per_col(&nnz_array[0])

        return nnz_array

    cpdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} reshape(self,
                                                        {{IDX_T}} rows,
                                                        {{IDX_T}} cols):

        cdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} mat

        mat = fast_lil_matrix_{{PYIDX}}_{{PYVALUE}}(rows, cols)
        del mat.vov
        mat.vov = self.vov.reshape(rows, cols)

        return mat

    cpdef fromcsr(self,
                  indices,
                  indptr,
                  data):

        self.vov.fromcsr(<cnp.PyArrayObject*>indices,
                         <cnp.PyArrayObject*>indptr,
                         <cnp.PyArrayObject*>data)

    cpdef tocsr(self):

        cdef {{IDX_T}} nnz = self.vov.getnnz_all()

        data = np.empty(nnz, dtype=np.{{PYVALUE}})
        indices = np.empty(nnz, dtype=np.{{PYIDX}})
        indptr = np.empty(self.rows + 1, dtype=np.{{PYIDX}})

        self.vov.tocsr(<cnp.PyArrayObject*>indices,
                       <cnp.PyArrayObject*>indptr,
                       <cnp.PyArrayObject*>data)

        return indices, indptr, data

    cpdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} copy(self):

        cdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} mat

        mat = fast_lil_matrix_{{PYIDX}}_{{PYVALUE}}(self.rows, self.cols)
        del mat.vov
        mat.vov = self.vov.copy()

        return mat
{{endfor}}
