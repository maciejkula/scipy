# -*- cython -*-
# cython: boundscheck=False, wraparound=False, cdivision=True, initializedcheck=False
# distutils: language = c++
#
#
# Tempita-templated Cython file
#
"""
Fast snippets for LIL matrices.
"""

ctypedef long double ldouble
ctypedef float complex fcomplex
ctypedef double complex dcomplex
ctypedef long double complex ldcomplex

{{py:

IDX_TYPES = {
    "int32": "cnp.npy_int32",
    "int64": "cnp.npy_int64",
}

VALUE_TYPES = {
    "bool": "cnp.npy_bool",
    "int8": "cnp.npy_int8",
    "uint8": "cnp.npy_uint8",
    "int16": "cnp.npy_int16",
    "uint16": "cnp.npy_uint16",
    "int32": "cnp.npy_int32",
    "uint32": "cnp.npy_uint32",
    "int64": "cnp.npy_int64",
    "uint64": "cnp.npy_uint64",
    "float32": "cnp.npy_float32",
    "float64": "cnp.npy_float64",
    "float128": "cnp.npy_float128",
    "complex64": "fcomplex",
    "complex128": "dcomplex",
    "complex256": "ldcomplex",
}


def get_dispatch(types):
    for pyname, cyname in types.items():
        yield pyname, cyname

def get_dispatch2(types, types2):
    for pyname, cyname in types.items():
        for pyname2, cyname2 in types2.items():
            yield pyname, pyname2, cyname, cyname2
}}


cimport cython
cimport numpy as cnp
import numpy as np

from cython.operator cimport dereference as deref
from libcpp.vector cimport vector

cdef extern from "./sparsetools/vov.h" namespace "vov":
    cdef cppclass VOVMatrix[I, T]:
        VOVMatrix(I, I) except +
        void set(I, I, T) except +

        void set_unchecked(I, I, T)
        T get(I, I) except +
        T get_unchecked(I, I)
        void fromcsr(I*, I*, T*)
        void todense(T*)
        void tocsr(I*, I*, T*)
        void mul(T)
        VOVMatrix[I, T] *copy()
        I getnnz_all()
        void getnnz_per_row(I*)
        void getnnz_per_col(I*)
        I count_nonzero()
        VOVMatrix[I, T] *fancy_get_elems(I*, I*, I) except +
        VOVMatrix[I, T] *fancy_get_rows(I*, I) except +
        VOVMatrix[I, T] *fancy_get_cols(I*, I) except +
        VOVMatrix[I, T] *fancy_get(I*, I*, I, I) except +


{{for PYIDX, PYVALUE, IDX_T, VALUE_T in get_dispatch2(IDX_TYPES, VALUE_TYPES)}}
cdef class fast_lil_matrix_{{PYIDX}}_{{PYVALUE}}:
    """
    Fast row-based matrix.
    """

    cdef {{IDX_T}} rows
    cdef {{IDX_T}} cols

    cdef vector[vector[{{IDX_T}}]] indices
    cdef vector[vector[{{VALUE_T}}]] data

    cdef VOVMatrix[{{IDX_T}}, {{VALUE_T}}] *vov

    def __init__(self, {{IDX_T}} rows, {{IDX_T}} cols):

        self.rows = rows
        self.cols = cols

        self.vov = new VOVMatrix[{{IDX_T}}, {{VALUE_T}}](rows, cols)

    def idx_dtype(self):
        """
        Return the index dtype.
        """

        return np.dtype('{{PYIDX}}')

    cdef void set(self, {{IDX_T}} row, {{IDX_T}} col, {{VALUE_T}} value):
        """
        Set (row, col) to value, without bounds checking.
        """

        self.vov.set_unchecked(row, col, value)

    def safe_set(self, {{IDX_T}} row, {{IDX_T}} col, {{VALUE_T}} value):
        """
        Set (row, col) to value, with bounds checking.
        """

        self.vov.set(row, col, value)

    def safe_get(self, {{IDX_T}} row, {{IDX_T}} col):
        """
        Get value at (row, col), with bounds checking.
        """

        return self.vov.get(row, col)

    cdef {{VALUE_T}} get(self, {{IDX_T}} row, {{IDX_T}} col):
        """
        Get value at (row, col), without bounds checking.
        """

        return self.vov.get_unchecked(row, col)

    cpdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} fancy_get_elems(self,
                                                                cnp.ndarray[{{IDX_T}}, ndim=1] row_indices,
                                                                cnp.ndarray[{{IDX_T}}, ndim=1] col_indices):
        """
        Fancy indexing: get elements at coordinates given by
        row and column indices.
        """

        cdef {{IDX_T}} rows, cols
        cdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} mat

        rows = 1
        cols = row_indices.shape[0]

        mat = fast_lil_matrix_{{PYIDX}}_{{PYVALUE}}(rows, cols)
        del mat.vov
        mat.vov = self.vov.fancy_get_elems(&row_indices[0],
                                           &col_indices[0],
                                           row_indices.shape[0])
        return mat

    cpdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} fancy_get_rows(self,
                                                               {{IDX_T}}[:] row_indices):
        """
        Fancy indexing: get rows indicated by row_indices.
        """

        cdef {{IDX_T}} i, rows, row_idx

        rows = row_indices.shape[0]

        mat = fast_lil_matrix_{{PYIDX}}_{{PYVALUE}}(rows, self.cols)
        del mat.vov
        mat.vov = self.vov.fancy_get_rows(&row_indices[0],
                                          row_indices.shape[0])

        return mat

    cpdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} fancy_get_cols(self,
                                                               {{IDX_T}}[:] col_indices):
        """
        Fancy indexing: get cols indicated by col_indices.
        """

        cdef {{IDX_T}} cols

        cols = col_indices.shape[0]

        mat = fast_lil_matrix_{{PYIDX}}_{{PYVALUE}}(self.rows, cols)
        del mat.vov
        mat.vov = self.vov.fancy_get_cols(&col_indices[0],
                                          col_indices.shape[0])

        return mat

    cpdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} fancy_get(self,
                                                          {{IDX_T}} rows,
                                                          {{IDX_T}} cols,
                                                          {{IDX_T}}[:, :] i_idx,
                                                          {{IDX_T}}[:, :] j_idx):
        """
        Fancy indexing: the rest.
        """

        cdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} mat

        mat = fast_lil_matrix_{{PYIDX}}_{{PYVALUE}}(rows, cols)
        del mat.vov
        mat.vov = self.vov.fancy_get(&i_idx[0, 0],
                                     &j_idx[0, 0],
                                     rows, cols)

        return mat

    cpdef fancy_set(self,
                    {{IDX_T}}[:, :] i_idx,
                    {{IDX_T}}[:, :] j_idx,
                    {{if PYVALUE == 'bool'}}
                    cnp.npy_uint8[:, :] data
                    {{else}}
                    {{VALUE_T}}[:, :] data
                    {{endif}}
    ):

        cdef {{IDX_T}} row_idx, col_idx, i, j
        cdef {{VALUE_T}} value
        cdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} mat
        cdef vector[{{IDX_T}}] *row_indices_vec
        cdef vector[{{VALUE_T}}] *row_data_vec

        for i in range(i_idx.shape[0]):

            row_indices_vec = &(self.indices[i])
            row_data_vec = &(self.data[i])

            for j in range(i_idx.shape[1]):
                row_idx = check_idx_{{PYIDX}}(i_idx[i, j], self.rows)
                col_idx = check_idx_{{PYIDX}}(j_idx[i, j], self.cols)

                if row_idx == -1 or col_idx == -1:
                    raise IndexError

                value = data[i, j]

                self.set(row_idx, col_idx, value)

    cpdef todense(self, dense):

        cdef unsigned long data_ptr = dense.ctypes.data

        self.vov.todense(<{{VALUE_T}}*>(<void*> data_ptr))

    cpdef mul(self, {{VALUE_T}} value):

        self.vov.mul(value);

    cpdef {{IDX_T}} count_nonzero(self):

        return self.vov.count_nonzero()

    cpdef getnnz(self, axis):

        cdef {{IDX_T}} i, j, col
        cdef {{IDX_T}} nnz = 0

        cdef vector[{{IDX_T}}] *row_indices
        cdef cnp.ndarray[{{IDX_T}}, ndim=1] nnz_array

        if axis is None:
            return self.vov.getnnz_all()

        if axis == 1:
            nnz_array = np.empty(self.rows, dtype=np.{{PYIDX}})
            self.vov.getnnz_per_row(&nnz_array[0])

        if axis == 0:
            nnz_array = np.zeros(self.cols, dtype=np.{{PYIDX}})
            self.vov.getnnz_per_col(&nnz_array[0])

        return nnz_array

    cpdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} reshape(self,
                                                        {{IDX_T}} rows,
                                                        {{IDX_T}} cols):

        cdef {{IDX_T}} row_idx, col_idx, i, new_row_idx, new_col_idx
        cdef {{VALUE_T}} value
        cdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} mat

        cdef vector[{{IDX_T}}] *self_indices_vec
        cdef vector[{{VALUE_T}}] *self_data_vec

        mat = fast_lil_matrix_{{PYIDX}}_{{PYVALUE}}(rows, cols)

        new_row_idx = 0

        for row_idx in range(self.rows):

            self_indices_vec = &(self.indices[row_idx])
            self_data_vec = &(self.data[row_idx])

            for i in range(self_indices_vec.size()):
                col_idx = deref(self_indices_vec)[i]
                value = deref(self_data_vec)[i]

                new_row_idx = (row_idx * self.cols + col_idx) / cols
                new_col_idx = (row_idx * self.cols + col_idx) % cols

                new_indices_vec = mat.indices[new_row_idx].push_back(new_col_idx)
                new_data_vec = mat.data[new_row_idx].push_back(value)

        return mat

    cpdef fromcsr(self,
                  cnp.ndarray[{{IDX_T}}, ndim=1] indices,
                  cnp.ndarray[{{IDX_T}}, ndim=1] indptr,
                  data):

        cdef unsigned long data_ptr = data.ctypes.data

        self.vov.fromcsr(&indices[0],
                         &indptr[0],
                         <{{VALUE_T}}*>(<void*> data_ptr))

    cpdef tocsr(self):

        cdef cnp.ndarray[{{IDX_T}}, ndim=1] indices
        cdef cnp.ndarray[{{IDX_T}}, ndim=1] indptr

        cdef {{IDX_T}} nnz = self.vov.getnnz_all()

        data = np.empty(nnz, dtype=np.{{PYVALUE}})
        indices = np.empty(nnz, dtype=np.{{PYIDX}})
        indptr = np.empty(self.rows + 1, dtype=np.{{PYIDX}})

        cdef unsigned long data_ptr = data.ctypes.data

        self.vov.tocsr(&indices[0],
                       &indptr[0],
                       <{{VALUE_T}}*>(<void*> data_ptr))

        return indices, indptr, data

    cpdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} copy(self):

        cdef fast_lil_matrix_{{PYIDX}}_{{PYVALUE}} mat

        mat = fast_lil_matrix_{{PYIDX}}_{{PYVALUE}}(self.rows, self.cols)
        del mat.vov
        mat.vov = self.vov.copy()

        return mat
{{endfor}}


{{for PYIDX, IDX_T in get_dispatch(IDX_TYPES)}}
cdef {{IDX_T}} binary_search_{{PYIDX}}({{IDX_T}}* vec, {{IDX_T}} size, {{IDX_T}} first, {{IDX_T}} last, {{IDX_T}} x) nogil:
    """
    Binary seach in an array of {{IDX_T}}s
    """

    cdef {{IDX_T}} mid, val

    mid = (first + last) >> 1

    while first < last:

        val = vec[mid]

        if val == x:
            return mid
        elif val < x:
            first = mid + 1
        else:
            last = mid

        mid = (first + last) >> 1

    return mid


cdef {{IDX_T}} check_idx_{{PYIDX}}({{IDX_T}} idx, {{IDX_T}} max_idx):

    if idx < 0:
        idx = max_idx + idx

    if idx >= max_idx or idx < 0:
        return -1
    else:
        return idx
{{endfor}}
